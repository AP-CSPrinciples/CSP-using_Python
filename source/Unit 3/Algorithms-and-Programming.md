# Algorithms & Programming


<details><summary>Big Ideas - Click Here</summary>

**Big Ideas Covered:**

* **Algorithms (AL)**
* **Abstraction (AB)**
* **Program Development (CRD)**
* **Data (DAT)**

**Comprehensive Outline**

**3.1: Variables and Assignments**

* Understanding variables as symbolic names storing values
* How assignment statements change values
* Naming conventions and best practices
* Types of data: integer, float, string, Boolean
* **Key Skill:** Create and manipulate variables

**3.2: Data Types**

* Identifying common data types
* Type compatibility and implicit vs explicit casting
* Boolean logic and conditionals
* **Key Skill:** Reason through variable types and predict outcomes

**3.3: Managing Complexity with Procedures (Functions)**

* Defining and calling functions
* Parameters and return values
* Purpose of abstraction in program design
* Reducing repetition and improving clarity
* **Key Skill:** Write and use procedures to break down problems

**3.4: Developing Procedures**

* Decomposing problems into subproblems
* Sequencing instructions
* Identifying reusable logic
* **Key Skill:** Create modular and readable code using procedures

**3.5: Algorithms**

* Understanding algorithms as step-by-step processes
* Expressing algorithms in code, pseudocode, or flowcharts
* Identifying sequence, selection, and iteration
* **Key Skill:** Analyze and write simple algorithms (e.g., search, sort)

**3.6: Boolean Expressions and If Statements**

* Using `if`, `else if`, and `else`
* Relational operators (`==`, `!=`, `>`, `<`, `>=`, `<=`)
* Logical operators (`AND`, `OR`, `NOT`)
* **Key Skill:** Write conditional logic to control program flow

**3.7: Iteration (Loops)**

* `for` loops and `while` loops
* Loop control: incrementing, breaking, and nested loops
* Trace and debug loop execution
* **Key Skill:** Use loops to automate repeated tasks

**3.8: Combining Elements to Solve Problems**

* Integrating variables, conditionals, and loops
* Building algorithms to solve complex problems
* Emphasis on testing and debugging
* **Key Skill:** Synthesize programming elements into working solutions

**3.9: Developing Algorithms**

* Using existing algorithms or creating new ones
* Refining and testing algorithms
* Representing algorithms as pseudocode and/or diagrams
* **Key Skill:** Plan, document, and implement multi-step logic

**3.10: Errors and Testing**

* Types of errors: syntax, logic, and runtime
* Use of test cases and debugging strategies
* Reading error messages and tracebacks
* **Key Skill:** Find and fix problems systematically

**3.11: Binary Search vs Linear Search**

* Linear search: simple, but slower for large data
* Binary search: faster, requires sorted data
* Tradeoffs in algorithm efficiency
* **Key Skill:** Compare search algorithms conceptually and in code

**3.12: Comparing Algorithmic Efficiency**

* Number of steps vs size of input (n)
* Informal analysis of algorithm runtime
* Big picture: efficiency impacts user experience and scalability
* **Key Skill:** Evaluate which algorithm is “better” and why

**3.13: Developing Programs**

* Problem identification, solution design
* Iterative development process: test, debug, refine
* Use of documentation and comments
* Collaboration and code review
* **Key Skill:** Design and build real programs with purpose

**Key Vocabulary**:

* Algorithm
* Abstraction
* Procedure
* Loop / Iteration
* Boolean
* Conditionals
* Debugging
* Linear/Binary Search
* Efficiency
* Input/Output
* Parameters / Return

**Suggested Activities:**

* **Debugging challenges**
* **Code tracing worksheets**
* **Huffman coding (as a stretch topic for algorithms)**
* **Block-based to text-based translation (e.g., Scratch to Python)**
* **Write and refine a simple calculator or game logic**
* **Pseudocode practice and flowcharts**

</details>

**AP CSP: Algorithms and Programming Project Packet**

Each project includes meaningful challenges in problem-solving, design, data abstraction, and algorithmic thinking, and supports multiple CSP standards.

---

<details> <summary>Project 1: Data Visualization Challenge</summary>

**College Board Learning Objectives:**

* DAT-2.D: Describe the purpose of a computational artifact.
* DAT-2.E: Create a computational artifact using data.
* AAP-2.J: Create programs that use libraries or APIs.

**Summary:**
Students will analyze a real-world dataset (e.g., climate, sports, health) and build a program that visualizes the data through graphs or interactive charts. They must clean the data, apply algorithms to extract meaning, and generate visual output.

**Deliverables:**

* Python or JavaScript program with visualization
* Annotated code with explanations
* 1-page summary of insights from the data

**Assessment Rubric:**

Project 1: Data Visualization Challenge

**College Board Learning Objectives:**

* DAT-2.D: Describe the purpose of a computational artifact.
* DAT-2.E: Create a computational artifact using data.
* AAP-2.J: Create programs that use libraries or APIs.

**Summary:**
Students will analyze a real-world dataset (e.g., climate, sports, health) and build a program that visualizes the data through graphs or interactive charts. They must clean the data, apply algorithms to extract meaning, and generate visual output.

**Deliverables:**

* Python or JavaScript program with visualization
* Annotated code with explanations
* 1-page summary of insights from the data

**Assessment Rubric:**

| Criteria                   | 4 - Excellent                                                  | 3 - Proficient                         | 2 - Developing                    | 1 - Beginning                           |
| -------------------------- | -------------------------------------------------------------- | -------------------------------------- | --------------------------------- | --------------------------------------- |
| Data Processing & Accuracy | Data is cleaned, processed, and represented with high accuracy | Data mostly processed correctly        | Some data processed, minor errors | Major issues or missing data processing |
| Program Functionality      | Fully functional and interactive                               | Mostly functional, minor bugs          | Partially functional              | Non-functional or incomplete            |
| Algorithm Use              | Well-structured and efficient algorithms                       | Logical and mostly correct             | Some inefficiency or errors       | Poor or no algorithmic structure        |
| Visualization Clarity      | Highly clear, informative, and visually appealing              | Generally clear and well-organized     | Some visual confusion             | Unclear or poorly designed              |
| Communication & Creativity | Excellent explanation and innovative presentation              | Clear explanation with some creativity | Basic explanation                 | Poorly explained or lacking originality |

---

</details>

<details><summary>Project 2: Custom Algorithm Design</summary>

**College Board Learning Objectives:**

* AAP-2.C: Develop an algorithm.
* AAP-2.G: Express an algorithm using sequencing, selection, and iteration.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students will identify a real-world or classroom problem and design a custom algorithm to solve it. The algorithm should include clear use of control structures and be implemented in code.

**Deliverables:**

* Problem description
* Flowchart or pseudocode
* Working program with documentation
* Analysis of algorithm efficiency (qualitative)

**Assessment Rubric:** 

Project 2: Custom Algorithm Design

**College Board Learning Objectives:**

* AAP-2.C: Develop an algorithm.
* AAP-2.G: Express an algorithm using sequencing, selection, and iteration.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students will identify a real-world or classroom problem and design a custom algorithm to solve it. The algorithm should include clear use of control structures and be implemented in code.

**Deliverables:**

* Problem description
* Flowchart or pseudocode
* Working program with documentation
* Analysis of algorithm efficiency (qualitative)

**Assessment Rubric:**

| Criteria              | 4 - Excellent                              | 3 - Proficient                              | 2 - Developing       | 1 - Beginning                      |
| --------------------- | ------------------------------------------ | ------------------------------------------- | -------------------- | ---------------------------------- |
| Problem Definition    | Clearly articulated and meaningful         | Clear and solvable                          | Vague or simplistic  | Unclear or undeveloped             |
| Algorithm Design      | Innovative, efficient, and well-structured | Logical with appropriate control structures | Some logical flaws   | Poor structure or missing elements |
| Code Implementation   | Clean, correct, and complete               | Mostly correct with some issues             | Partially functional | Incomplete or not working          |
| Algorithm Explanation | Insightful and clearly communicates logic  | Reasonably clear explanation                | Limited clarity      | Missing or incorrect explanation   |

---
</details>


<details><summary>Project 3: Text-Based Game Development</summary>

**College Board Learning Objectives:**

* AAP-2.I: Use procedures to organize code.
* AAP-2.M: Develop programs that use lists.
* AAP-2.N: Use procedures that operate on data in lists.

**Summary:**
Students will design and build a text-based adventure game using procedures and data structures. They will implement lists, control flow, and functions to support reusable code and dynamic behavior.

**Deliverables:**

* Fully functional game (e.g., Python, Java)
* Code with at least two custom procedures and one list-based mechanic
* Game map or flow diagram

**Assessment Rubric:** 

Project 3: Text-Based Game Development

**College Board Learning Objectives:**

* AAP-2.I: Use procedures to organize code.
* AAP-2.M: Develop programs that use lists.
* AAP-2.N: Use procedures that operate on data in lists.

**Summary:**
Students will design and build a text-based adventure game using procedures and data structures. They will implement lists, control flow, and functions to support reusable code and dynamic behavior.

**Deliverables:**

* Fully functional game (e.g., Python, Java)
* Code with at least two custom procedures and one list-based mechanic
* Game map or flow diagram

**Assessment Rubric:**

| Criteria                 | 4 - Excellent                                               | 3 - Proficient                   | 2 - Developing              | 1 - Beginning                          |
| ------------------------ | ----------------------------------------------------------- | -------------------------------- | --------------------------- | -------------------------------------- |
| Game Logic & Playability | Highly engaging and bug-free                                | Playable with minor bugs         | Playable but limited        | Unplayable or incomplete               |
| Procedures & Lists       | Uses multiple reusable procedures and well-integrated lists | Appropriate use of both elements | Limited or inconsistent use | Missing procedures or list integration |
| Code Structure           | Well-organized and readable                                 | Mostly clear organization        | Some disorganization        | Hard to follow or messy                |
| Creativity & Innovation  | Highly original and engaging concept                        | Some creativity                  | Basic or conventional       | Lacking originality                    |

---

</details>


<details><summary>Project 4: Simulations</summary>


**Big Idea 4: Algorithms and Programming**

* **Computational Thinking Practice:** Developing and implementing algorithms; abstracting and modeling.

* **Learning Objective 4.2:**
  *The student can use simulations to represent real-world phenomena or examine their behaviors under varying conditions.*

* **Essential Knowledge statements:**

  * **4.2A:** Simulations can be used to model real-world events and predict outcomes.
  * **4.2B:** Computer models and simulations use abstraction to represent real phenomena.
  * **4.2C:** Random number generation can be used to model the variability in real-world situations.

### Getting Started with NetLogo Web

**Instructions for students**

1. Open your browser and go to [https://www.netlogoweb.org](https://www.netlogoweb.org). This is the web‐version of NetLogo, which works in Chromebooks or any modern browser. ([ccl.northwestern.edu][1])
2. Once loaded, you’ll see the interface with tabs like *Interface*, *Info*, *Code* (depending on the model).
3. Click the drop‐down menu (Search the Models Library) and choose a model from the built-in library. The Info tab will help you understand it. ([ccl.northwestern.edu][1])
4. Typical workflow:

   * Click **Setup** (or a similar button) to initialize the world.
   * Click **Go** (or a run button) to start the simulation.
   * You may adjust sliders, switches, buttons on the Interface to change parameters.
5. In the *Info* tab you’ll often find a description of what the model simulates, how agents behave, any experiments you can do.
6. In the *Code* tab you can look at how the model is implemented (students don’t always need to modify it, but it’s useful to inspect).
7. Some coding and color conventions: In the Code editor, different kinds of words (primitives, reporters, etc) are color-highlighted, helping readability. ([ccl.northwestern.edu][2])
8. A few tips:

   * Try different parameter values (sliders) and observe the effect.
   * Take notes: what happens when you change something? Why do you think that is?
   * Use the *Info* tab to read about what the authors intended.
   * If something hangs or seems slow, you can stop the model and reset. Note that NetLogo Web may be slower than the desktop version. ([netlogoweb.org][3])

---

#### Traffic Basic

**Model:** Use the built-in *Traffic Basic* model (or any simple model you pick from the Models Library that runs in Web).
**Goal:** Get comfortable with Setup/Go, sliders/switches, exploring what happens when parameters change.

**Steps for students:**

1. Load the model (Search the Models Library → “Traffic Basic” or similar).
2. In the Interface tab, inspect the controls: what sliders or switches are available?
3. Press **Setup**. Observe what the world looks like.
4. Press **Go**. Let the simulation run for a few seconds. Then press **Go** again or stop it.
5. Change one slider value (for example, number of cars, speed limit, etc), then press Setup and Go again. What changed?
6. Try changing a switch (for example turn traffic lights on/off) if present. Again, Setup/Go and observe.
7. Optional command center exploration: you can interact via the Command Center (for example choose “turtles” and make a command like `set color blue`) to change agent colors and observe effect. ([docs.netlogo.org][4])

**Questions for the practice tutorial:**

1. What slider or parameter did you alter? What was its original value and what did you change it to?
2. After you changed the parameter and ran the model, what difference did you observe in the simulation?
3. Why do you think that parameter had the effect that it did?
4. Using the Info tab, what is the purpose of this model? Summarize in your own words.
5. In the Code tab, find one line that uses `ask turtles [...]` (or similar). What is that line doing?
6. Reflect: Did you notice anything surprising or unexpected when you changed a parameter? What would you like to try next?

---

#### Project 1: Wolf/Sheep Predation

**Model:** Use the built‐in “Wolf Sheep Predation” model.
**Task:** Run the model several times with different parameter values and answer the questions below.

**Steps for students:**

1. Load the model via the library.
2. Explore the Interface: there will be parameters like number of sheep, number of wolves, reproduction rates, grass regrowth, etc.
3. Press Setup → then Go. Let the simulation run until things settle or until you choose to stop.
4. Record what you observe (graph trends, populations rising/falling).
5. Change one parameter (for example increase number of wolves, or decrease sheep reproduction rate). Press Setup → Go and observe again.
6. Change a different parameter again (for example speed of wolves, amount of grass). Observe.
7. Try at least 3 different runs with varied parameters and compare results.

**Questions for Wolf/Sheep:**

1. What were your initial values for: number of sheep, number of wolves, sheep reproduction rate, wolf reproduction rate (or grass regrowth) – list them.
2. What happened to the sheep population over time in your first run? What happened to the wolf population?
3. In your second run (after you changed a parameter), how did the outcomes differ? What changed for the sheep? For the wolves?
4. Which parameter change seemed to have the biggest impact on the system? Why do you think that is?
5. Did the system reach a steady state, oscillation, or extinction (of wolves or sheep)? Explain.
6. Looking at the Code tab, find the line(s) where wolves “eat sheep” (or sheep eat grass). Describe in your own words how that mechanism is coded.
7. If you were to *design* a new experiment in this model (for example adding another predator, or limiting grass differently), what would you try and why?

---

#### Project 2: Traffic Grid

**Model:** Use the built-in “Traffic Grid” (or similar) model that simulates cars moving on a city grid with traffic lights.
**Task:** Explore how traffic flow is affected by density, speed limits, number of lights, etc.

**Steps for students:**

1. Load the Traffic Grid model via the library.
2. Examine the sliders/switches: e.g., number of cars, speed limit, ticks for light change, etc.
3. Press Setup → Go. Observe how traffic flows and how many cars get stopped, average speed, etc.
4. Change one parameter (for example double number of cars). Setup → Go. Observe changes.
5. Change another parameter (for example alter the light-cycle duration or speed limit). Setup → Go. Observe.
6. Use the graph/plots (if available) to record values like average speed or stopped cars.

**Questions for Traffic Grid:**

1. What parameter values did you use for your first run (number of cars, speed limit, tick interval for lights)?
2. In the first run, how did traffic move? Did you see gridlock, smooth flow, many cars stopped? Explain.
3. After you increased the number of cars, what changed? What happened to average speed and stopped cars?
4. When you adjusted light timing (or speed limit), how did that affect traffic flow? What is your hypothesis for why?
5. Which parameter seemed most important in determining traffic flow efficiency? Justify your answer.
6. In the Code tab, find where the cars check for a red light (or where they slow down). Describe briefly how that logic works.
7. If you could redesign the intersection system (for example change road layout or add more lanes), what experiment would you run to test improved flow?

---

#### Project 3: Fire Spread

**Model:** Use the built‐in “Fire” model (simulation of fire spreading through a forest of patches).
**Task:** Investigate how tree density, wind, dryness affect fire spread and containment.

**Steps for students:**

1. Load the Fire model from the library.
2. Notice parameters: tree density, probability of fire spread, wind direction/speed (if present).
3. Press Setup → Go. Watch how fire spreads through the forest of patches.
4. Change one parameter (e.g., increase tree density) then Setup → Go. Observe difference.
5. Change another parameter (e.g., increase wind speed or direction) then Setup → Go. Observe.
6. Record observations: how quickly fire spreads, how many patches burn vs survive.

**Questions for Fire Spread:**

1. What were your initial parameter values (tree density, spread probability, wind speed/direction)?
2. In your first run, what pattern did the fire spread follow? Did it burn through most trees, stop early, create isolated patches?
3. After increasing tree density, how did the fire behaviour change? What was different?
4. After adjusting wind (or dryness), what additional changes did you observe?
5. Which combination of parameters resulted in the **least** damage (fewest burned patches)? What does that teach you about fire spread?
6. In the Code tab, find where a patch of type “tree” checks nearby patches for burning. Describe that logic in your own words.
7. If you were designing a fire-safe forest, what parameter values might you choose (and why)? What experiment would you run to test it?

---

#### Project 4: Dice / Random Experiment

**Model:** Create or use a simple dice simulation (if there is a built-in model; if not, you can create one in NetLogo Web). For example: simulate rolling two dice many times and count the sums, or simulate many agents rolling dice and tracking results.
**Task:** Use NetLogo Web to run a simulation of repeated random events, collect data (counts/frequencies) and answer questions about probability distribution, fairness, etc.
**Steps for students:**

1. If a built-in model exists (“Dice” or “Die Roll”), load it. If not, you may create a simple version:

   * Setup: create many turtles; each turtle has two variables (die1, die2) using `set die1 random 6 + 1`, `set die2 random 6 + 1` etc.
   * Go: ask turtles to roll again, tally sum, update a plot/histogram.
2. Use the simulation: run for, say, 100, 1000, 10 000 trials (if feasible).
3. Record frequencies of sums (2–12) or whatever your experiment is.
4. Change something: e.g., bias one die (set probabilities differently), or use three dice instead of two. Run again and observe the distribution.

**Questions for Dice Simulation:**

1. What is the theoretical probability distribution for rolling two fair six-sided dice (sums from 2 to 12)? Describe it (which sums are most likely, least likely).
2. In your first simulation run (with fair dice), what did you observe? Did your experimental frequencies roughly match the theoretical distribution? Provide a summary of results.
3. When you changed something (for example biased a die or added a third die), how did the distribution change? Provide the observed differences.
4. Why do you think the distribution changed when you made that alteration? Explain using probability reasoning.
5. In the Code tab, locate where the dice are rolled (e.g., `random 6 + 1`). Write down the line and explain what it does.
6. If you were designing a “fair game” using this simulation, what parameters would you ensure (and why)?
7. Optional extension: Design a new experiment (e.g., roll two dice 1000 times and track how many times you get doubles, or track the longest streak of a particular sum). What would you test and why?

---

</details>


<details><summary>Project 5: Algorithm Museum (Explainer Showcase)</summary>

**College Board Learning Objectives:**

* AAP-2.L: Explain how algorithms reflect different approaches to solving problems.
* CRD-2.C: Identify inputs and outputs of a program.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students select a classic algorithm (e.g., sorting, searching, pathfinding) and create an interactive or visual explainer. They must describe inputs/outputs, explain its function, and compare it with an alternative.

**Deliverables:**

* Explainer artifact (video, animation, poster, slideshow, etc.)
* Input/output examples
* Comparative write-up

**Assessment Rubric:**

Project 5: Algorithm Museum (Explainer Showcase)

**College Board Learning Objectives:**

* AAP-2.L: Explain how algorithms reflect different approaches to solving problems.
* CRD-2.C: Identify inputs and outputs of a program.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students select a classic algorithm (e.g., sorting, searching, pathfinding) and create an interactive or visual explainer. They must describe inputs/outputs, explain its function, and compare it with an alternative.

**Deliverables:**

* Explainer artifact (video, animation, poster, slideshow, etc.)
* Input/output examples
* Comparative write-up

**Assessment Rubric:**

| Criteria                | 4 - Excellent                                   | 3 - Proficient           | 2 - Developing                 | 1 - Beginning                         |
| ----------------------- | ----------------------------------------------- | ------------------------ | ------------------------------ | ------------------------------------- |
| Algorithm Explanation   | Clear, deep explanation with visuals/examples   | Mostly clear explanation | Some confusion or gaps         | Inaccurate or unclear explanation     |
| Inputs & Outputs        | Well-explained with accurate examples           | Mostly correct           | Minor errors or omissions      | Missing or incorrect examples         |
| Comparison & Evaluation | Thoughtful comparison of two or more approaches | Adequate comparison      | Limited insight or explanation | No meaningful comparison              |
| Presentation Quality    | Polished, creative, and informative             | Clear and informative    | Somewhat unclear               | Hard to understand or poorly executed |

---

</details>

