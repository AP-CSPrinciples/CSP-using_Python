# Algorithms & Programming


<details><summary>Big Ideas - Click Here</summary>

**Big Ideas Covered:**

* **Algorithms (AL)**
* **Abstraction (AB)**
* **Program Development (CRD)**
* **Data (DAT)**

**Comprehensive Outline**

**3.1: Variables and Assignments**

* Understanding variables as symbolic names storing values
* How assignment statements change values
* Naming conventions and best practices
* Types of data: integer, float, string, Boolean
* **Key Skill:** Create and manipulate variables

**3.2: Data Types**

* Identifying common data types
* Type compatibility and implicit vs explicit casting
* Boolean logic and conditionals
* **Key Skill:** Reason through variable types and predict outcomes

**3.3: Managing Complexity with Procedures (Functions)**

* Defining and calling functions
* Parameters and return values
* Purpose of abstraction in program design
* Reducing repetition and improving clarity
* **Key Skill:** Write and use procedures to break down problems

**3.4: Developing Procedures**

* Decomposing problems into subproblems
* Sequencing instructions
* Identifying reusable logic
* **Key Skill:** Create modular and readable code using procedures

**3.5: Algorithms**

* Understanding algorithms as step-by-step processes
* Expressing algorithms in code, pseudocode, or flowcharts
* Identifying sequence, selection, and iteration
* **Key Skill:** Analyze and write simple algorithms (e.g., search, sort)

**3.6: Boolean Expressions and If Statements**

* Using `if`, `else if`, and `else`
* Relational operators (`==`, `!=`, `>`, `<`, `>=`, `<=`)
* Logical operators (`AND`, `OR`, `NOT`)
* **Key Skill:** Write conditional logic to control program flow

**3.7: Iteration (Loops)**

* `for` loops and `while` loops
* Loop control: incrementing, breaking, and nested loops
* Trace and debug loop execution
* **Key Skill:** Use loops to automate repeated tasks

**3.8: Combining Elements to Solve Problems**

* Integrating variables, conditionals, and loops
* Building algorithms to solve complex problems
* Emphasis on testing and debugging
* **Key Skill:** Synthesize programming elements into working solutions

**3.9: Developing Algorithms**

* Using existing algorithms or creating new ones
* Refining and testing algorithms
* Representing algorithms as pseudocode and/or diagrams
* **Key Skill:** Plan, document, and implement multi-step logic

**3.10: Errors and Testing**

* Types of errors: syntax, logic, and runtime
* Use of test cases and debugging strategies
* Reading error messages and tracebacks
* **Key Skill:** Find and fix problems systematically

**3.11: Binary Search vs Linear Search**

* Linear search: simple, but slower for large data
* Binary search: faster, requires sorted data
* Tradeoffs in algorithm efficiency
* **Key Skill:** Compare search algorithms conceptually and in code

**3.12: Comparing Algorithmic Efficiency**

* Number of steps vs size of input (n)
* Informal analysis of algorithm runtime
* Big picture: efficiency impacts user experience and scalability
* **Key Skill:** Evaluate which algorithm is ‚Äúbetter‚Äù and why

**3.13: Developing Programs**

* Problem identification, solution design
* Iterative development process: test, debug, refine
* Use of documentation and comments
* Collaboration and code review
* **Key Skill:** Design and build real programs with purpose

**Key Vocabulary**:

* Algorithm
* Abstraction
* Procedure
* Loop / Iteration
* Boolean
* Conditionals
* Debugging
* Linear/Binary Search
* Efficiency
* Input/Output
* Parameters / Return

**Suggested Activities:**

* **Debugging challenges**
* **Code tracing worksheets**
* **Huffman coding (as a stretch topic for algorithms)**
* **Block-based to text-based translation (e.g., Scratch to Python)**
* **Write and refine a simple calculator or game logic**
* **Pseudocode practice and flowcharts**

</details>

**AP CSP: Algorithms and Programming Project Packet**

Each project includes meaningful challenges in problem-solving, design, data abstraction, and algorithmic thinking, and supports multiple CSP standards.

---

<details> <summary>Project 1: Data Visualization Challenge</summary>

**College Board Learning Objectives:**

* DAT-2.D: Describe the purpose of a computational artifact.
* DAT-2.E: Create a computational artifact using data.
* AAP-2.J: Create programs that use libraries or APIs.

**Summary:**
Students will analyze a real-world dataset (e.g., climate, sports, health) and build a program that visualizes the data through graphs or interactive charts. They must clean the data, apply algorithms to extract meaning, and generate visual output.

**Deliverables:**

* Python or JavaScript program with visualization
* Annotated code with explanations
* 1-page summary of insights from the data

**Assessment Rubric:**

Project 1: Data Visualization Challenge

**College Board Learning Objectives:**

* DAT-2.D: Describe the purpose of a computational artifact.
* DAT-2.E: Create a computational artifact using data.
* AAP-2.J: Create programs that use libraries or APIs.

**Summary:**
Students will analyze a real-world dataset (e.g., climate, sports, health) and build a program that visualizes the data through graphs or interactive charts. They must clean the data, apply algorithms to extract meaning, and generate visual output.

**Deliverables:**

* Python or JavaScript program with visualization
* Annotated code with explanations
* 1-page summary of insights from the data

**Assessment Rubric:**

| Criteria                   | 4 - Excellent                                                  | 3 - Proficient                         | 2 - Developing                    | 1 - Beginning                           |
| -------------------------- | -------------------------------------------------------------- | -------------------------------------- | --------------------------------- | --------------------------------------- |
| Data Processing & Accuracy | Data is cleaned, processed, and represented with high accuracy | Data mostly processed correctly        | Some data processed, minor errors | Major issues or missing data processing |
| Program Functionality      | Fully functional and interactive                               | Mostly functional, minor bugs          | Partially functional              | Non-functional or incomplete            |
| Algorithm Use              | Well-structured and efficient algorithms                       | Logical and mostly correct             | Some inefficiency or errors       | Poor or no algorithmic structure        |
| Visualization Clarity      | Highly clear, informative, and visually appealing              | Generally clear and well-organized     | Some visual confusion             | Unclear or poorly designed              |
| Communication & Creativity | Excellent explanation and innovative presentation              | Clear explanation with some creativity | Basic explanation                 | Poorly explained or lacking originality |

---

</details>

<details><summary>Project 2: Custom Algorithm Design</summary>

**College Board Learning Objectives:**

* AAP-2.C: Develop an algorithm.
* AAP-2.G: Express an algorithm using sequencing, selection, and iteration.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students will identify a real-world or classroom problem and design a custom algorithm to solve it. The algorithm should include clear use of control structures and be implemented in code.

**Deliverables:**

* Problem description
* Flowchart or pseudocode
* Working program with documentation
* Analysis of algorithm efficiency (qualitative)

**Assessment Rubric:** 

Project 2: Custom Algorithm Design

**College Board Learning Objectives:**

* AAP-2.C: Develop an algorithm.
* AAP-2.G: Express an algorithm using sequencing, selection, and iteration.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students will identify a real-world or classroom problem and design a custom algorithm to solve it. The algorithm should include clear use of control structures and be implemented in code.

**Deliverables:**

* Problem description
* Flowchart or pseudocode
* Working program with documentation
* Analysis of algorithm efficiency (qualitative)

**Assessment Rubric:**

| Criteria              | 4 - Excellent                              | 3 - Proficient                              | 2 - Developing       | 1 - Beginning                      |
| --------------------- | ------------------------------------------ | ------------------------------------------- | -------------------- | ---------------------------------- |
| Problem Definition    | Clearly articulated and meaningful         | Clear and solvable                          | Vague or simplistic  | Unclear or undeveloped             |
| Algorithm Design      | Innovative, efficient, and well-structured | Logical with appropriate control structures | Some logical flaws   | Poor structure or missing elements |
| Code Implementation   | Clean, correct, and complete               | Mostly correct with some issues             | Partially functional | Incomplete or not working          |
| Algorithm Explanation | Insightful and clearly communicates logic  | Reasonably clear explanation                | Limited clarity      | Missing or incorrect explanation   |

---
</details>


<details><summary>Project 3: Text-Based Game Development</summary>

**College Board Learning Objectives:**

* AAP-2.I: Use procedures to organize code.
* AAP-2.M: Develop programs that use lists.
* AAP-2.N: Use procedures that operate on data in lists.

**Summary:**
Students will design and build a text-based adventure game using procedures and data structures. They will implement lists, control flow, and functions to support reusable code and dynamic behavior.

**Deliverables:**

* Fully functional game (e.g., Python, Java)
* Code with at least two custom procedures and one list-based mechanic
* Game map or flow diagram

**Assessment Rubric:** 

Project 3: Text-Based Game Development

**College Board Learning Objectives:**

* AAP-2.I: Use procedures to organize code.
* AAP-2.M: Develop programs that use lists.
* AAP-2.N: Use procedures that operate on data in lists.

**Summary:**
Students will design and build a text-based adventure game using procedures and data structures. They will implement lists, control flow, and functions to support reusable code and dynamic behavior.

**Deliverables:**

* Fully functional game (e.g., Python, Java)
* Code with at least two custom procedures and one list-based mechanic
* Game map or flow diagram

**Assessment Rubric:**

| Criteria                 | 4 - Excellent                                               | 3 - Proficient                   | 2 - Developing              | 1 - Beginning                          |
| ------------------------ | ----------------------------------------------------------- | -------------------------------- | --------------------------- | -------------------------------------- |
| Game Logic & Playability | Highly engaging and bug-free                                | Playable with minor bugs         | Playable but limited        | Unplayable or incomplete               |
| Procedures & Lists       | Uses multiple reusable procedures and well-integrated lists | Appropriate use of both elements | Limited or inconsistent use | Missing procedures or list integration |
| Code Structure           | Well-organized and readable                                 | Mostly clear organization        | Some disorganization        | Hard to follow or messy                |
| Creativity & Innovation  | Highly original and engaging concept                        | Some creativity                  | Basic or conventional       | Lacking originality                    |

---

</details>


<details><summary>Project 4: Simulations</summary>


**Big Idea 4: Algorithms and Programming**

* **Computational Thinking Practice:** Developing and implementing algorithms; abstracting and modeling.

* **Learning Objective 4.2:**
  *The student can use simulations to represent real-world phenomena or examine their behaviors under varying conditions.*

* **Essential Knowledge statements:**

  * **4.2A:** Simulations can be used to model real-world events and predict outcomes.
  * **4.2B:** Computer models and simulations use abstraction to represent real phenomena.
  * **4.2C:** Random number generation can be used to model the variability in real-world situations.

### Getting Started with NetLogo Web

**Instructions for students**

1. Open your browser and go to [https://www.netlogoweb.org](https://www.netlogoweb.org). This is the web‚Äêversion of NetLogo, which works in Chromebooks or any modern browser.
2. Once loaded, you‚Äôll see the interface with tabs like *Interface*, *Info*, *Code* (depending on the model).
3. Click the drop‚Äêdown menu (Search the Models Library) and choose a model from the built-in library. The Info tab will help you understand it.
4. Typical workflow:

   * Click **Setup** (or a similar button) to initialize the world.
   * Click **Go** (or a run button) to start the simulation.
   * You may adjust sliders, switches, buttons on the Interface to change parameters.
5. In the *Info* tab you‚Äôll often find a description of what the model simulates, how agents behave, any experiments you can do.
6. In the *Code* tab you can look at how the model is implemented (students don‚Äôt always need to modify it, but it‚Äôs useful to inspect).
7. Some coding and color conventions: In the Code editor, different kinds of words (primitives, reporters, etc) are color-highlighted, helping readability. ([ccl.northwestern.edu][2])
8. A few tips:

   * Try different parameter values (sliders) and observe the effect.
   * Take notes: what happens when you change something? Why do you think that is?
   * Use the *Info* tab to read about what the authors intended.
   * If something hangs or seems slow, you can stop the model and reset. Note that NetLogo Web may be slower than the desktop version. ([netlogoweb.org][3])

---

#### Traffic Basic

**Model:** Use the built-in *Traffic Basic* model (or any simple model you pick from the Models Library that runs in Web).
**Goal:** Get comfortable with Setup/Go, sliders/switches, exploring what happens when parameters change.

**Steps for students:**

1. Load the model (Search the Models Library ‚Üí ‚ÄúTraffic Basic‚Äù or similar).
2. In the Interface tab, inspect the controls: what sliders or switches are available?
3. Press **Setup**. Observe what the world looks like.
4. Press **Go**. Let the simulation run for a few seconds. Then press **Go** again or stop it.
5. Change one slider value (for example, number of cars, speed limit, etc), then press Setup and Go again. What changed?
6. Try changing a switch (for example turn traffic lights on/off) if present. Again, Setup/Go and observe.
7. Optional command center exploration: you can interact via the Command Center (for example choose ‚Äúturtles‚Äù and make a command like `set color blue`) to change agent colors and observe effect. ([docs.netlogo.org][4])

**Questions for the practice tutorial:**

1. What slider or parameter did you alter? What was its original value and what did you change it to?
2. After you changed the parameter and ran the model, what difference did you observe in the simulation?
3. Why do you think that parameter had the effect that it did?
4. Using the Info tab, what is the purpose of this model? Summarize in your own words.
5. In the Code tab, find one line that uses `ask turtles [...]` (or similar). What is that line doing?
6. Reflect: Did you notice anything surprising or unexpected when you changed a parameter? What would you like to try next?

---

#### Project 1: Wolf/Sheep Predation

**Model:** Use the built‚Äêin ‚ÄúWolf Sheep Predation‚Äù model.
**Task:** Run the model several times with different parameter values and answer the questions below.

**Steps for students:**

1. Load the model via the library.
2. Explore the Interface: there will be parameters like number of sheep, number of wolves, reproduction rates, grass regrowth, etc.
3. Press Setup ‚Üí then Go. Let the simulation run until things settle or until you choose to stop.
4. Record what you observe (graph trends, populations rising/falling).
5. Change one parameter (for example increase number of wolves, or decrease sheep reproduction rate). Press Setup ‚Üí Go and observe again.
6. Change a different parameter again (for example speed of wolves, amount of grass). Observe.
7. Try at least 3 different runs with varied parameters and compare results.

**Questions for Wolf/Sheep:**

1. What were your initial values for: number of sheep, number of wolves, sheep reproduction rate, wolf reproduction rate (or grass regrowth) ‚Äì list them.
2. What happened to the sheep population over time in your first run? What happened to the wolf population?
3. In your second run (after you changed a parameter), how did the outcomes differ? What changed for the sheep? For the wolves?
4. Which parameter change seemed to have the biggest impact on the system? Why do you think that is?
5. Did the system reach a steady state, oscillation, or extinction (of wolves or sheep)? Explain.
6. Looking at the Code tab, find the line(s) where wolves ‚Äúeat sheep‚Äù (or sheep eat grass). Describe in your own words how that mechanism is coded.
7. If you were to *design* a new experiment in this model (for example adding another predator, or limiting grass differently), what would you try and why?

---

#### Project 2: Traffic Grid

**Model:** Use the built-in ‚ÄúTraffic Grid‚Äù (or similar) model that simulates cars moving on a city grid with traffic lights.
**Task:** Explore how traffic flow is affected by density, speed limits, number of lights, etc.

**Steps for students:**

1. Load the Traffic Grid model via the library.
2. Examine the sliders/switches: e.g., number of cars, speed limit, ticks for light change, etc.
3. Press Setup ‚Üí Go. Observe how traffic flows and how many cars get stopped, average speed, etc.
4. Change one parameter (for example double number of cars). Setup ‚Üí Go. Observe changes.
5. Change another parameter (for example alter the light-cycle duration or speed limit). Setup ‚Üí Go. Observe.
6. Use the graph/plots (if available) to record values like average speed or stopped cars.

**Questions for Traffic Grid:**

1. What parameter values did you use for your first run (number of cars, speed limit, tick interval for lights)?
2. In the first run, how did traffic move? Did you see gridlock, smooth flow, many cars stopped? Explain.
3. After you increased the number of cars, what changed? What happened to average speed and stopped cars?
4. When you adjusted light timing (or speed limit), how did that affect traffic flow? What is your hypothesis for why?
5. Which parameter seemed most important in determining traffic flow efficiency? Justify your answer.
6. In the Code tab, find where the cars check for a red light (or where they slow down). Describe briefly how that logic works.
7. If you could redesign the intersection system (for example change road layout or add more lanes), what experiment would you run to test improved flow?

---

#### Project 3: Fire Spread

**Model:** Use the built‚Äêin ‚ÄúFire‚Äù model (simulation of fire spreading through a forest of patches).
**Task:** Investigate how tree density, wind, dryness affect fire spread and containment.

**Steps for students:**

1. Load the Fire model from the library.
2. Notice parameters: tree density, probability of fire spread, wind direction/speed (if present).
3. Press Setup ‚Üí Go. Watch how fire spreads through the forest of patches.
4. Change one parameter (e.g., increase tree density) then Setup ‚Üí Go. Observe difference.
5. Change another parameter (e.g., increase wind speed or direction) then Setup ‚Üí Go. Observe.
6. Record observations: how quickly fire spreads, how many patches burn vs survive.

**Questions for Fire Spread:**

1. What were your initial parameter values (tree density, spread probability, wind speed/direction)?
2. In your first run, what pattern did the fire spread follow? Did it burn through most trees, stop early, create isolated patches?
3. After increasing tree density, how did the fire behaviour change? What was different?
4. After adjusting wind (or dryness), what additional changes did you observe?
5. Which combination of parameters resulted in the **least** damage (fewest burned patches)? What does that teach you about fire spread?
6. In the Code tab, find where a patch of type ‚Äútree‚Äù checks nearby patches for burning. Describe that logic in your own words.
7. If you were designing a fire-safe forest, what parameter values might you choose (and why)? What experiment would you run to test it?

---

#### Project 4: Dice / Random Experiment

**Model:** Create or use a simple dice simulation (if there is a built-in model; if not, you can create one in NetLogo Web). For example: simulate rolling two dice many times and count the sums, or simulate many agents rolling dice and tracking results.
**Task:** Use NetLogo Web to run a simulation of repeated random events, collect data (counts/frequencies) and answer questions about probability distribution, fairness, etc.

**Steps for students:**

1. If a built-in model exists (‚ÄúDice‚Äù or ‚ÄúDie Roll‚Äù), load it. If not, you may create a simple version:
   * Setup: create many turtles; each turtle has two variables (die1, die2) using `set die1 random 6 + 1`, `set die2 random 6 + 1` etc.
   * Go: ask turtles to roll again, tally sum, update a plot/histogram.
2. Use the simulation: run for, say, 100, 1000, 10 000 trials (if feasible).
3. Record frequencies of sums (2‚Äì12) or whatever your experiment is.
4. Change something: e.g., bias one die (set probabilities differently), or use three dice instead of two. Run again and observe the distribution.

**Questions for Dice Simulation:**

1. What is the theoretical probability distribution for rolling two fair six-sided dice (sums from 2 to 12)? Describe it (which sums are most likely, least likely).
2. In your first simulation run (with fair dice), what did you observe? Did your experimental frequencies roughly match the theoretical distribution? Provide a summary of results.
3. When you changed something (for example biased a die or added a third die), how did the distribution change? Provide the observed differences.
4. Why do you think the distribution changed when you made that alteration? Explain using probability reasoning.
5. In the Code tab, locate where the dice are rolled (e.g., `random 6 + 1`). Write down the line and explain what it does.
6. If you were designing a ‚Äúfair game‚Äù using this simulation, what parameters would you ensure (and why)?
7. Optional extension: Design a new experiment (e.g., roll two dice 1000 times and track how many times you get doubles, or track the longest streak of a particular sum). What would you test and why?

---

</details>


<details><summary>Project 5: Algorithm Museum (Explainer Showcase)</summary>

**College Board Learning Objectives:**

* AAP-2.L: Explain how algorithms reflect different approaches to solving problems.
* CRD-2.C: Identify inputs and outputs of a program.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students select a classic algorithm (e.g., sorting, searching, pathfinding) and create an interactive or visual explainer. They must describe inputs/outputs, explain its function, and compare it with an alternative.

**Deliverables:**

* Explainer artifact (video, animation, poster, slideshow, etc.)
* Input/output examples
* Comparative write-up

**Assessment Rubric:**

Project 5: Algorithm Museum (Explainer Showcase)

**College Board Learning Objectives:**

* AAP-2.L: Explain how algorithms reflect different approaches to solving problems.
* CRD-2.C: Identify inputs and outputs of a program.
* AAP-2.K: Evaluate algorithms.

**Summary:**
Students select a classic algorithm (e.g., sorting, searching, pathfinding) and create an interactive or visual explainer. They must describe inputs/outputs, explain its function, and compare it with an alternative.

**Deliverables:**

* Explainer artifact (video, animation, poster, slideshow, etc.)
* Input/output examples
* Comparative write-up

**Assessment Rubric:**

| Criteria                | 4 - Excellent                                   | 3 - Proficient           | 2 - Developing                 | 1 - Beginning                         |
| ----------------------- | ----------------------------------------------- | ------------------------ | ------------------------------ | ------------------------------------- |
| Algorithm Explanation   | Clear, deep explanation with visuals/examples   | Mostly clear explanation | Some confusion or gaps         | Inaccurate or unclear explanation     |
| Inputs & Outputs        | Well-explained with accurate examples           | Mostly correct           | Minor errors or omissions      | Missing or incorrect examples         |
| Comparison & Evaluation | Thoughtful comparison of two or more approaches | Adequate comparison      | Limited insight or explanation | No meaningful comparison              |
| Presentation Quality    | Polished, creative, and informative             | Clear and informative    | Somewhat unclear               | Hard to understand or poorly executed |

---


</details>


<details><summary>Sorting</summary>

**Merge Sort**

```python
counter = 0 # to track the number of comparisons

def merge_sort(arr):
    """ Merge Sort, Complexity: O(n log(n)) """
    global counter
    
    # our recursive base case
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    
    counter += 1 # add to the comparison counter
    # perform merge_sort recursively on both halves
    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])

    # merge each side together
    return merge(left, right, arr.copy())

def merge(left, right, merged):
    """ Merge helper, Complexity: O(n) """

    left_cursor, right_cursor = 0, 0
    while left_cursor < len(left) and right_cursor < len(right):
        # sort each one and place into the result
        if left[left_cursor] <= right[right_cursor]:
            merged[left_cursor+right_cursor]=left[left_cursor]
            left_cursor += 1
        else:
            merged[left_cursor + right_cursor] = right[right_cursor]
            right_cursor += 1
    # add the left overs if there's any left to the result
    for left_cursor in range(left_cursor, len(left)):
        merged[left_cursor + right_cursor] = left[left_cursor]
    # add the left overs if there's any left to the result
    for right_cursor in range(right_cursor, len(right)):
        merged[left_cursor + right_cursor] = right[right_cursor]

    # return result
    return merged

def get_counter():
    global counter
    return counter
  
if __name__ == "__main__":
    array = [12, 5, 11, 6, -3, -4, -11, 6, 3, 4, 1, -2]
    array = merge_sort(array)
    print(array)
    print("Number of comparisons:", get_counter())
```


---


**Insertion Sort**

```python
counter = 0 # to track the number of comparisons

def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp

def insertionsort(array):
    global counter

    for i in range(1, len(array)):
        unsorted = array[i]

        # a marker to hold the last element of the sorted portion
        marker = i - 1

        # loop backwards through the sorted portion
        while marker >= 0:
            counter += 1
            if unsorted < array[marker]:
                swap(array, marker, marker + 1)
            else:
                break
            marker -= 1

def get_counter():
    global counter
    return counter

if __name__ == "__main__":
    array = [12, 5, 11, 6, -3, -4, -11, 6, 3, 4, 1, -2]
    insertionsort(array)
    print(array)
    print("Number of comparisons:", get_counter())
```


---


**Quick Sort**
    

```python
counter = 0 # to track the number of comparisons

def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp

def partition(array, start, end):
    global counter
    """ quicksort partitioning, using end """
    pivot = array[end]
    L = start
    R = end
    while L < R:
        while array[L] < pivot:
            L += 1
            counter += 1
        while array[R] > pivot:
            R -= 1
            counter += 1
        swap(array, L, R)
        # avoid hanging on the same numbers
        if ( array[L] == array[R] ):
            L += 1
    return R

def _quicksort(array, start, end):
    """ Recursive quicksort function """
    global counter
    if start < end:
        counter += 1
        split = partition(array, start, end)
        _quicksort(array, start, split-1)
        _quicksort(array, split+1, end)

def quicksort(array):
    _quicksort(array, 0, len(array)-1)
    
def get_counter():
    global counter
    return counter

if __name__ == "__main__":
    array = [12, 5, 11, 6, -3, -4, -11, 6, 3, 4]
    quicksort(array)
    print(array)
    print("Number of comparisons:", get_counter())
```


---


**Bubble Sort**


```python
counter = 0 # to track the number of comparisons

def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp

def bubblesort(array):
    global counter
    n = len(array)-1
    for i in range(0, len(array)):
        for j in range(0, n):
            if array[j] > array[j+1]:
                counter += 1
                swap(array, j+1, j)
        n -= 1
    return array
    
def get_counter():
    global counter
    return counter

if __name__ == "__main__":
    array = [12, 5, 11, 6, -3, -4, -11, 6, 3, 4, 1, -2]
    array = bubblesort(array)
    print(array)
    print("Number of comparisons:", get_counter())
```


---


</details>


<details><summary>GUI Development Project</summary>


**Part 1:** How to Create a GUI (Step-by-Step with Code)

This section walks you through **how to build a GUI for the first time**.  
Each step includes **example code** and **key vocabulary**.

You will be using **Python + Tkinter**.

[Tkinter Resource](https://tkdocs.com/tutorial/intro.html#audience)

[Python Support Docs](https://docs.python.org/3/)

---

**Step 1:** Define the Purpose (Requirements)

Before writing code, decide:
- What problem does the program solve?
- What can the user do?
- What input and output are required?

üìå *Vocabulary:* requirements, input, output, user interaction

```python
# Purpose:
# This GUI allows the user to add two numbers
# Inputs: two numbers
# Output: the sum
```

---

**Step 2:** Choose the GUI Framework

Select a framework and import required modules.

üìå *Vocabulary:* framework, library, module, dependency

```python
import tkinter as tk
from tkinter import messagebox
```

---

> **Built-in Tkinter Modules (Standard Library)**
> 
> These modules are included with Python's standard library and provide additional functionality or themed widgets: 
>
> tkinter.ttk -> This module provides access to the Tk themed widgets (Ttk), which offer a more modern, native look and feel across different platforms compared to classic Tk widgets.
> 
> tkinter.filedialog -> Provides standard dialogs for file selection (open, save, etc.).
> 
> tkinter.simpledialog -> Offers basic dialog windows for inputting values.
> 
> tkinter.messagebox -> Used for displaying message prompts and confirmation dialogs.
> 
> tkinter.colorchooser -> Provides a dialog for selecting colors.
> 
> tkinter.font -> A wrapper for working with fonts.
> 
> tkinter.scrolledtext -> Provides a text widget with a built-in scrollbar.
> 
> tkinter.dnd -> Adds drag-and-drop support.


---

**Step 3:** Create the Main Window

Create the **root window** and configure its properties.

üìå *Vocabulary:* root window, application window, geometry

```python
window = tk.Tk()
window.title("Simple Calculator")
window.geometry("300x250")
window.resizable(False, False)
```

---

**Step 4:** Plan the Layout

**What is an effective GUI Design & Layout**

**A. Visual Organization**

* Elements are **aligned** (buttons, labels, inputs line up cleanly)
* Related items are **grouped together**
* The layout is not cluttered or overcrowded
* There is appropriate **spacing** between elements

**Exceeds Expectations**

* Layout is intuitive and easy to scan
* Clear visual hierarchy (important items stand out)

---

**B. Consistency**

* Fonts, colors, and button styles are consistent throughout
* Similar actions use similar controls (e.g., all actions use buttons)
* Labels follow the same format (capitalization, wording)

**Exceeds Expectations**

* Consistency improves usability and reduces confusion

---

**C. Readability**

* Text is large enough to read easily
* Font style is simple and appropriate
* Good contrast between text and background

**Exceeds Expectations**

* Design choices make information instantly understandable

---

**D. Logical Layout**

* GUI follows a natural flow (top-to-bottom or left-to-right)
* User knows what to do **without instructions**
* Inputs appear before outputs

**Exceeds Expectations**

* User interaction feels natural and predictable

---

**E. Usability**

* Buttons are clearly labeled
* Controls are easy to click or interact with
* User receives feedback (messages, updates, results shown)

**Exceeds Expectations**

* GUI prevents user errors or makes recovery easy

---

**F. Aesthetics**

* Colors are visually pleasing and not distracting
* Design supports the purpose of the application
* No unnecessary decorations or visual noise

**Exceeds Expectations**

* Visual design enhances the overall user experience

---

**G. Screen Fit & Responsiveness** 

* GUI fits within the window without scrolling
* Elements do not overlap
* Resizing the window does not break the layout *(if applicable)*

**Exceeds Expectations**

* Layout adapts cleanly to different window sizes

---

**H. Accessibility**

* Labels clearly describe inputs
* Color is not the only way information is conveyed
* Design considers users with different needs

**Exceeds Expectations**

* GUI is usable by a wider range of users

---


> A good GUI should be **organized, consistent, readable, easy to use, and visually clear**.
> As a general guide, if a user can understand how to use it **without instructions**, the design is effective.

---

Decide how widgets will be arranged on the screen.

üìå *Vocabulary:* layout, [layout manager](https://docs.python.org/3/library/tkinter.html), grid, alignment

```python
# This program uses the grid layout manager
```

---

**Step 5:** Add GUI Components (Widgets)

Create the visual elements the user interacts with.

üìå *Vocabulary:* widget, component, control

```python
label_title = tk.Label(window, text="Add Two Numbers")
label_num1 = tk.Label(window, text="Number 1:")
entry_num1 = tk.Entry(window)

label_num2 = tk.Label(window, text="Number 2:")
entry_num2 = tk.Entry(window)

calculate_button = tk.Button(window, text="Calculate")
result_label = tk.Label(window, text="Result:")
```

---

**Step 6:** Configure Widget Properties

Adjust text, size, spacing, and appearance.

üìå *Vocabulary:* properties, attributes, configuration

```python
label_title.config(font=("Arial", 14), pady=10)
calculate_button.config(width=15)
```

---

**Step 7:** Handle User Events

**Define *event handlers* that run when the user interacts.**

üìå *Vocabulary:* event, event-driven programming, callback

```python
def calculate_sum():
    try:
        num1 = float(entry_num1.get())
        num2 = float(entry_num2.get())
        result_label.config(text=f"Result: {num1 + num2}")
    except ValueError:
        messagebox.showerror("Error", "Enter valid numbers")
```

---

**Step 8:** Connect Events to Widgets

Link user actions to functions.

üìå *Vocabulary:* event binding, command callback

```python
calculate_button.config(command=calculate_sum)
```

---

**Step 9:** Apply the Layout Manager

Place widgets on the screen.

üìå *Vocabulary:* grid system, spacing

```python
label_title.grid(row=0, column=0, columnspan=2)
label_num1.grid(row=1, column=0)
entry_num1.grid(row=1, column=1)

label_num2.grid(row=2, column=0)
entry_num2.grid(row=2, column=1)

calculate_button.grid(row=3, column=0, columnspan=2, pady=10)
result_label.grid(row=4, column=0, columnspan=2)
```

---

**Step 10:** Display Output to the User

Update labels or show message boxes.

üìå *Vocabulary:* output display, user feedback

```python
result_label.config(text="Result: 10")
```

---

**Step 11:** Test and Debug

Run the program and test:

* Valid input
* Invalid input
* Button behavior

üìå *Vocabulary:* testing, debugging, runtime error

```python
window.mainloop()
```

---

**Step 12:** Finalize and Document

Add comments and clean up code.

üìå *Vocabulary:* documentation, refactoring

```python
# This program demonstrates a basic event-driven GUI
# using Tkinter for AP CSP students
```

---


> A GUI program is *event-driven* ‚Äî it waits for the user to do something.


---


**Part 2:** AP CSP GUI Project

**Project Overview**

You will design and build your **own GUI-based program** using the steps above.

Your program must:

* Accept user input
* Respond to user events
* Process data using program logic
* Display meaningful output

---

**Project Choices:**

**üü¢ Easy Projects** +0

Choose one:

* **A Calculator(0-9,+,/,+,-,.)**
* **Temperature Converter**
* **Click Counter**

---

**üü° Moderate Projects** +2

Choose one:

* **Grade Calculator**
* **Simple To-Do List**
* **Random Password Generator**

---

**üî¥ Challenging Projects** +4

Choose one:

* **Unit Conversion Dashboard**
* **Quiz Application**
* **Expense Tracker**

---

**Required Features**

Your project must include:

* At least **3 widgets**
* At least **1 event handler**
* Input validation
* Clear output

---

**Universal Rubric (10 Points)**

| Category            | Points |
| ------------------- | ------ |
| GUI Design & Layout | 2      |
| Functionality       | 2      |
| Event Handling      | 2      |
| Program Logic       | 2      |
| Input Validation    | 1      |
| Documentation       | 1      |
| **Total**           | **10** |

---

**Submission Requirements**

Submit:

* Python source code
* Short written explanation as a **block comment** at the bottom your program:

  * What does your program do?
  * How does the user interact with it?
  * Where is user input handled?
  * Where is program logic implemented?

---

**Final Reminder**

Design your program for the **user**, not just the computer.



</details>



---





















